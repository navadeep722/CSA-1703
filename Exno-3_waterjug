from collections import deque
def water_jug_bfs(x, y, d):
    visited = set()
    q = deque()
    q.append(((0, 0), []))  # initial state and path
    while q:
        (a, b), path = q.popleft()
        if (a, b) in visited:
            continue
        visited.add((a, b))
        path = path + [(a, b)]

        if a == d or b == d:
            return path
        # All possible moves
        next_states = set([
            (x, b),     # Fill jug X
            (a, y),     # Fill jug Y
            (0, b),     # Empty jug X
            (a, 0),     # Empty jug Y
            (min(a + b, x), max(0, b - (x - a))),  # Pour Y -> X
            (max(0, a - (y - b)), min(a + b, y)),  # Pour X -> Y
        ])
        for state in next_states:
            if state not in visited:
                q.append((state, path))
    return None  # No solution
def print_solution(path):
    for i, (a, b) in enumerate(path):
        print(f"Step {i}: Jug1 = {a}L, Jug2 = {b}L")
# Example usage
if __name__ == "__main__":
    X, Y, D = 4, 3, 2
    solution = water_jug_bfs(X, Y, D)
    print("192371068-D.Navadeep")
    if solution:
        print("Solution found:")
        print_solution(solution)
    else:
        print("No solution exists.")
